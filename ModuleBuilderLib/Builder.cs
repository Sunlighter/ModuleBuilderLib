using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection.Emit;
using System.Text;

namespace Sunlighter.ModuleBuilderLib
{
    public static class Builder
    {
        public static ImmutableList<T> TopologicalSort<T>(ImmutableList<T> items, Func<T, ImmutableHashSet<T>> getParents)
        {
            ImmutableList<T> results = ImmutableList<T>.Empty;
            ImmutableList<T> items1 = items;
            ImmutableList<T> items2 = ImmutableList<T>.Empty;
            ImmutableHashSet<T> inResults = ImmutableHashSet<T>.Empty;

            while (items1.Count > 0)
            {
                foreach (T item in items1)
                {
                    ImmutableHashSet<T> h1 = getParents(item);
                    h1 = h1.Except(inResults);
                    if (h1.IsEmpty)
                    {
                        results = results.Add(item);
                        inResults = inResults.Add(item);
                    }
                    else
                    {
                        items2 = items2.Add(item);
                    }
                }

                if (items2.Count == items1.Count) throw new Exception("Topological Sort: cycles detected");

                items1 = items2;
                items2 = ImmutableList<T>.Empty;
            }

            return results;
        }

        public static ImmutableDictionary<ItemKey, Type> Compile(this ModuleBuilder mb, ModuleToBuild mtb)
        {
            SymbolTable s = SymbolTable.Empty;
            s = mtb.DefineSymbols(s);

            ImmutableList<ICompileStep> steps = mtb.GetCompileSteps(s);

            ImmutableHashSet<ItemKey> allItemKeys = steps.Select(x => x.Inputs).UnionAll().Union(steps.Select(x => x.Outputs).UnionAll());

            ImmutableDictionary<ItemKey, SaBox<object>> references = ImmutableDictionary<ItemKey, SaBox<object>>.Empty;
            foreach (ItemKey ik in allItemKeys) references = references.Add(ik, new SaBox<object>());

            ImmutableDictionary<ItemKey, ImmutableHashSet<int>> inputDict = ImmutableDictionary<ItemKey, ImmutableHashSet<int>>.Empty;
            ImmutableDictionary<ItemKey, int> outputDict = ImmutableDictionary<ItemKey, int>.Empty;

            int iEnd = steps.Count;
            for (int i = 0; i < iEnd; ++i)
            {
                if (steps[i].Phase == 1)
                {
                    foreach (ItemKey ik in steps[i].Inputs)
                    {
                        if (inputDict.ContainsKey(ik))
                        {
                            inputDict = inputDict.SetItem(ik, inputDict[ik].Add(i));
                        }
                        else
                        {
                            inputDict = inputDict.Add(ik, ImmutableHashSet<int>.Empty.Add(i));
                        }
                    }
                    foreach (ItemKey ik in steps[i].Outputs)
                    {
                        if (outputDict.ContainsKey(ik))
                        {
                            throw new Exception("Output conflict: " + ik + " is generated by two different steps");
                        }
                        else
                        {
                            outputDict = outputDict.Add(ik, i);
                        }
                    }
                }
            }

            Func<int, ImmutableHashSet<int>> getParents = delegate (int i)
            {
                ImmutableHashSet<ItemKey> inputs = steps[i].Inputs;
                ImmutableHashSet<ItemKey> cantMake = inputs.Where(x => !outputDict.ContainsKey(x)).ToImmutableHashSet();
                if (!(cantMake.IsEmpty))
                {
                    throw new Exception("Don't know how to make " + cantMake.Select(x => x.ToString()).Concatenate(", "));
                }
                ImmutableHashSet<int> suppliers = inputs.Select(x => outputDict[x]).ToImmutableHashSet();
                return suppliers;
            };

            ImmutableList<int> phase1 = TopologicalSort<int>(Enumerable.Range(0, iEnd).Where(x => steps[x].Phase == 1).ToImmutableList(), getParents);

            foreach (int i in phase1)
            {
                steps[i].Compile(mb, references);
            }

            ImmutableHashSet<ItemKey> phase1Results = steps.Where(x => x.Phase == 1).Select(x => x.Outputs).UnionAll();

            Func<int, ImmutableHashSet<int>> getParents2 = delegate (int i)
            {
                ImmutableHashSet<ItemKey> inputs = steps[i].Inputs.Except(phase1Results);
                ImmutableHashSet<ItemKey> cantMake = inputs.Where(x => !outputDict.ContainsKey(x)).ToImmutableHashSet();

                if (!(cantMake.IsEmpty))
                {
                    throw new Exception("Don't know how to make " + cantMake.Select(x => x.ToString()).Concatenate(", "));
                }
                ImmutableHashSet<int> suppliers = inputs.Select(x => outputDict[x]).ToImmutableHashSet();
                return suppliers;
            };

            ImmutableList<int> phase2 = TopologicalSort<int>(Enumerable.Range(0, iEnd).Where(x => steps[x].Phase == 2).ToImmutableList(), getParents2);

            foreach (int i in phase2)
            {
                steps[i].Compile(mb, references);
            }

            ImmutableHashSet<ItemKey> phase2Results = steps.Where(x => x.Phase == 2).Select(x => x.Outputs).UnionAll();

            return phase2Results.ToImmutableDictionary(x => x, x => (Type)(references[x].Value));
        }
    }

    public static partial class Extensions
    {
        public static string Concatenate(this IEnumerable<string> strings, string delimiter)
        {
            StringBuilder sb = new StringBuilder();
            bool needDelim = false;
            foreach (string str in strings)
            {
                if (needDelim) sb.Append(delimiter);
                sb.Append(str);
                needDelim = true;
            }
            return sb.ToString();
        }

        public static ImmutableHashSet<T> UnionAll<T>(this IEnumerable<ImmutableHashSet<T>> sets)
        {
            ImmutableHashSet<T> r = ImmutableHashSet<T>.Empty;
            foreach (ImmutableHashSet<T> s in sets)
            {
                r = r.Union(s);
            }
            return r;
        }
    }
}
