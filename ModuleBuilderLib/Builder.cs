using Sunlighter.OptionLib;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection.Emit;

namespace Sunlighter.ModuleBuilderLib
{
    public static class BuilderOfModules
    {
        public static ImmutableList<T> TopologicalSort<T>(ImmutableList<T> items, Func<T, ImmutableSortedSet<T>> getParents, Option<IComparer<T>> comparer)
        {
            ImmutableList<T> results = ImmutableList<T>.Empty;
            ImmutableList<T> items1 = items;
            ImmutableList<T> items2 = ImmutableList<T>.Empty;
            ImmutableSortedSet<T> inResults = ImmutableSortedSet<T>.Empty;
            if (comparer.HasValue) inResults = inResults.WithComparer(comparer.Value);

            while (items1.Count > 0)
            {
                foreach (T item in items1)
                {
                    ImmutableSortedSet<T> h1 = getParents(item);
                    h1 = h1.Except(inResults);
                    if (h1.IsEmpty)
                    {
                        results = results.Add(item);
                        inResults = inResults.Add(item);
                    }
                    else
                    {
                        items2 = items2.Add(item);
                    }
                }

                if (items2.Count == items1.Count) throw new Exception("Topological Sort: cycles detected");

                items1 = items2;
                items2 = ImmutableList<T>.Empty;
            }

            return results;
        }

        public static ImmutableDictionary<ItemKey, Type> Compile(this ModuleBuilder mb, ModuleToBuild mtb)
        {
            SymbolTable s = SymbolTable.Empty;
            s = mtb.DefineSymbols(s);

            ImmutableList<ICompileStep> steps = mtb.GetCompileSteps(s);

            ImmutableSortedSet<ItemKey> allItemKeys = ImmutableSortedSet<ItemKey>.Empty.UnionAll(steps.Select(x => x.Inputs)).UnionAll(steps.Select(x => x.Outputs));

            ImmutableSortedDictionary<ItemKey, SaBox<object>> references = ImmutableSortedDictionary<ItemKey, SaBox<object>>.Empty;
            foreach (ItemKey ik in allItemKeys) references = references.Add(ik, new SaBox<object>());

            ImmutableSortedDictionary<ItemKey, ImmutableSortedSet<int>> inputDict = ImmutableSortedDictionary<ItemKey, ImmutableSortedSet<int>>.Empty;
            ImmutableSortedDictionary<ItemKey, int> outputDict = ImmutableSortedDictionary<ItemKey, int>.Empty;

            int iEnd = steps.Count;
            for (int i = 0; i < iEnd; ++i)
            {
                if (steps[i].Phase == 1)
                {
                    foreach (ItemKey ik in steps[i].Inputs)
                    {
                        if (inputDict.ContainsKey(ik))
                        {
                            inputDict = inputDict.SetItem(ik, inputDict[ik].Add(i));
                        }
                        else
                        {
                            inputDict = inputDict.Add(ik, ImmutableSortedSet<int>.Empty.Add(i));
                        }
                    }
                    foreach (ItemKey ik in steps[i].Outputs)
                    {
                        if (outputDict.ContainsKey(ik))
                        {
                            throw new Exception("Output conflict: " + ik + " is generated by two different steps");
                        }
                        else
                        {
                            outputDict = outputDict.Add(ik, i);
                        }
                    }
                }
            }

            Func<int, ImmutableSortedSet<int>> getParents = delegate (int i)
            {
                ImmutableSortedSet<ItemKey> inputs = steps[i].Inputs;
                ImmutableSortedSet<ItemKey> cantMake = inputs.Where(x => !outputDict.ContainsKey(x)).ToImmutableSortedSet();
                if (!(cantMake.IsEmpty))
                {
                    throw new Exception("Don't know how to make " + string.Join(", ", cantMake.Select(x => x.ToString())));
                }
                ImmutableSortedSet<int> suppliers = inputs.Select(x => outputDict[x]).ToImmutableSortedSet();
                return suppliers;
            };

            ImmutableList<int> phase1 = TopologicalSort(Enumerable.Range(0, iEnd).Where(x => steps[x].Phase == 1).ToImmutableList(), getParents, Option<IComparer<int>>.None);

            foreach (int i in phase1)
            {
                steps[i].Compile(mb, references);
            }

            ImmutableSortedSet<ItemKey> phase1Results = ImmutableSortedSet<ItemKey>.Empty.UnionAll(steps.Where(x => x.Phase == 1).Select(x => x.Outputs));

            Func<int, ImmutableSortedSet<int>> getParents2 = delegate (int i)
            {
                ImmutableSortedSet<ItemKey> inputs = steps[i].Inputs.Except(phase1Results);
                ImmutableSortedSet<ItemKey> cantMake = inputs.Where(x => !outputDict.ContainsKey(x)).ToImmutableSortedSet();

                if (!(cantMake.IsEmpty))
                {
                    throw new Exception("Don't know how to make " + string.Join(", ", cantMake.Select(x => x.ToString())));
                }
                ImmutableSortedSet<int> suppliers = inputs.Select(x => outputDict[x]).ToImmutableSortedSet();
                return suppliers;
            };

            ImmutableList<int> phase2 = TopologicalSort(Enumerable.Range(0, iEnd).Where(x => steps[x].Phase == 2).ToImmutableList(), getParents2, Option<IComparer<int>>.None);

            foreach (int i in phase2)
            {
                steps[i].Compile(mb, references);
            }

            ImmutableSortedSet<ItemKey> phase2Results = ImmutableSortedSet<ItemKey>.Empty.UnionAll(steps.Where(x => x.Phase == 2).Select(x => x.Outputs));

            return phase2Results.ToImmutableDictionary(x => x, x => (Type)(references[x].Value));
        }
    }

    public static partial class Extensions
    {
        public static ImmutableSortedSet<T> UnionAll<T>(this IEnumerable<ImmutableSortedSet<T>> sets)
        {
            ImmutableSortedSet<T> result = ImmutableSortedSet<T>.Empty;
            bool isFirst = true;
            foreach (ImmutableSortedSet<T> s in sets)
            {
                if (isFirst && s.KeyComparer != null)
                {
                    result = result.WithComparer(s.KeyComparer);
                }
                isFirst = false;
                result = result.Union(s);
            }
            return result;
        }

        public static ImmutableSortedSet<T> UnionAll<T>(this ImmutableSortedSet<T> empty, IEnumerable<ImmutableSortedSet<T>> sets)
        {
            ImmutableSortedSet<T> result = empty;
            foreach (ImmutableSortedSet<T> s in sets)
            {
                result = result.Union(s);
            }
            return result;
        }
    }
}
